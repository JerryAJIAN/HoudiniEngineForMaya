global proc int
houdiniEngine_freezeAsset(string $assetNode)
{
    if( `getAttr ( $assetNode + ".frozen")` ) {
    	print "Error: Asset is already frozen\n";
	return 0;
    }
    // add  atring attributes for caching asset output connections
    if(`attributeExists "cachedSrc" $assetNode`)
        deleteAttr ( $assetNode + ".cachedSrc");
    select $assetNode;
    addAttr -longName "cachedSrc" -dt "string" -multi;

    if(`attributeExists "cachedDst" $assetNode`)
        deleteAttr ( $assetNode + ".cachedDst");
    select $assetNode;
    addAttr -longName "cachedDst" -dt "string" -multi;
    setAttr  ( $assetNode + ".frozen" ) 1;
    // disconnect output objects
       
    string $outputObjCon[] = `listConnections -p on ($assetNode + ".outputObjects")`;
    int $attrIndex = 0;
    for($con in $outputObjCon) {
        string $src = `connectionInfo -sfd $con`;
	string $discon = $con;

	// if a mesh output has auxiliary nodes or downstream history
	// need a temporary mesh shape to backstop the history
	if(endsWith($src, "outputPartMeshData")) {
	    if(nodeType(plugNode($con)) != "mesh") {
		string $proxyMesh = `createNode mesh -n "houdiniAssetProxyMesh#" -parent $assetNode`;
		connectAttr $src ($proxyMesh + ".inMesh");

		// force a compute of the mesh before disconnecting so that it has data
		polyEvaluate $proxyMesh;
		$discon = $proxyMesh + ".inMesh";
		connectAttr -f  ($proxyMesh + ".outMesh") $con;
		setAttr ($proxyMesh + ".intermediateObject") 1;
	    }
	}
	setAttr ( $assetNode + ".cachedSrc[" + $attrIndex +"]") -type "string"  $src;
	setAttr ( $assetNode + ".cachedDst[" + $attrIndex +"]") -type "string" $con;
	disconnectAttr $src $discon;
	$attrIndex++;
    }

    // disconnect output materials
    string $outputMatCon[] = `listConnections -p on ($assetNode + ".outputMaterials")`;

    for($con in $outputMatCon) {
        string $src = `connectionInfo -sfd $con`;
	disconnectAttr $src $con;
	setAttr ( $assetNode + ".cachedSrc[" + $attrIndex +"]") -type "string"  $src;
	setAttr ( $assetNode + ".cachedDst[" + $attrIndex +"]") -type "string" $con;
	$attrIndex++;
    }
    
    // disconnect output instancers
    string $outputInstCon[] = `listConnections -p on ($assetNode + ".outputInstancers")`;

    for($con in $outputInstCon) {
        string $src = `connectionInfo -sfd $con`;
	disconnectAttr $src $con;
	setAttr ( $assetNode + ".cachedSrc[" + $attrIndex +"]") -type "string"  $src;
	setAttr ( $assetNode + ".cachedDst[" + $attrIndex +"]") -type "string" $con;
	$attrIndex++;
    }

    // don't disconnect output transforms, since they connect back to the asset
    // connection is determinded by the asset options
    // and not a particular output

    // freeze input merge nodes
    string $inputMergeCon[] = `listConnections -type "houdiniInputMerge" $assetNode`;
    for($merge in  $inputMergeCon) {
        setAttr  ( $merge + ".frozen" ) 1;
    }
    
    return 1;
}

global proc int
houdiniEngine_unfreezeAsset(string $assetNode)
{
    if( !`getAttr ( $assetNode + ".frozen")` ) {
    	print "Error: Asset is not frozen\n";
	return 0;
    }

    // unfreeze asset
    setAttr  ( $assetNode + ".frozen" ) 0;
    // unfreeze input merge nodes
    string $inputMergeCon[] = `listConnections -type "houdiniInputMerge" $assetNode`;
    for($merge in  $inputMergeCon) {
        setAttr  ( $merge + ".frozen" ) 0;
    }
    houdiniAsset -reloadNoSync $assetNode;

    // can't restore the connections if one of the cached connection atts isn't there
    if(!`attributeExists "cachedSrc" $assetNode` || !`attributeExists "cachedDst" $assetNode`) {
        if(`attributeExists "cachedDst" $assetNode`)
	    deleteAttr ( $assetNode + ".cachedDst");
        if(`attributeExists "cachedSrc" $assetNode`)
	    deleteAttr ( $assetNode + ".cachedSrc");
        return 0;
    }

    // set the asset node to blocking - we don't want it to cook on each connectAttr
    setAttr  ( $assetNode + ".nodeState") 2;
    // disconnect output objects
       
    int $ai = 0;
    int $numCon = `getAttr -size  ($assetNode + ".cachedSrc")`;
    for($ai = 0; $ai  < $numCon; $ai++) {
	string $src = `getAttr ( $assetNode + ".cachedSrc[" + $ai +"]")`;
	string $dst = `getAttr ( $assetNode + ".cachedDst[" + $ai +"]")`;

	// if an output that needs reconnecting has an input mesh, it's either
	// the mesh we added to backstop downstream history when we did the freeze
	string $dstNode = plugNode($dst);
	string $inputProxies[] = `listConnections -type "mesh" -d off -shapes on $dstNode`;
	
	connectAttr -f $src $dst;
	
	// delete them only after they're been forced to disconnect, otherwise
	// maya's delete might take some of the downstream history with it
	for($proxy in  $inputProxies) {
             delete $proxy;
	}
    }
    
    setAttr  ( $assetNode + ".nodeState") 0;

    deleteAttr ( $assetNode + ".cachedSrc");
    deleteAttr ( $assetNode + ".cachedDst");

    return 1;
}


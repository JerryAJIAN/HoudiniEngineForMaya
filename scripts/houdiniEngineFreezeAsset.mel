global proc int
houdiniEngine_freezeAsset(string $assetNode)
{
    if( `getAttr ( $assetNode + ".frozen")` ) {
    	print "Error: Asset is already frozen\n";
	return 0;
    }
    // add  atring attributes for caching asset output connections
    if(`attributeExists "cachedSrc" $assetNode`)
        deleteAttr ( $assetNode + ".cachedSrc");
    select $assetNode;
    addAttr -longName "cachedSrc" -dt "string" -multi;

    if(`attributeExists "cachedDst" $assetNode`)
        deleteAttr ( $assetNode + ".cachedDst");
    select $assetNode;
    addAttr -longName "cachedDst" -dt "string" -multi;
    setAttr  ( $assetNode + ".frozen" ) 1;
    // disconnect output objects
       
    string $outputObjCon[] = `listConnections -p on ($assetNode + ".outputObjects")`;
    int $attrIndex = 0;
    for($con in $outputObjCon) {
        string $src = `connectionInfo -sfd $con`;
	setAttr ( $assetNode + ".cachedSrc[" + $attrIndex +"]") -type "string"  $src;
	setAttr ( $assetNode + ".cachedDst[" + $attrIndex +"]") -type "string" $con;
	disconnectAttr $src $con;
	$attrIndex++;
    }

    // disconnect output materials
    string $outputMatCon[] = `listConnections -p on ($assetNode + ".outputMaterials")`;

    for($con in $outputMatCon) {
        string $src = `connectionInfo -sfd $con`;
	disconnectAttr $src $con;
	setAttr ( $assetNode + ".cachedSrc[" + $attrIndex +"]") -type "string"  $src;
	setAttr ( $assetNode + ".cachedDst[" + $attrIndex +"]") -type "string" $con;
	$attrIndex++;
    }
    
    // disconnect output instancers
    string $outputInstCon[] = `listConnections -p on ($assetNode + ".outputInstancers")`;

    for($con in $outputInstCon) {
        string $src = `connectionInfo -sfd $con`;
	disconnectAttr $src $con;
	setAttr ( $assetNode + ".cachedSrc[" + $attrIndex +"]") -type "string"  $src;
	setAttr ( $assetNode + ".cachedDst[" + $attrIndex +"]") -type "string" $con;
	$attrIndex++;
    }

    // don't disconnect output transforms, since they connect back to the asset
    // connection is determinded by the asset options
    // and not a particular output

    // freeze input merge nodes
    string $inputMergeCon[] = `listConnections -type "houdiniInputMerge" $assetNode`;
    for($merge in  $inputMergeCon) {
        setAttr  ( $merge + ".frozen" ) 1;
    }
    
    return 1;
}

global proc int
houdiniEngine_unfreezeAsset(string $assetNode)
{
    if( !`getAttr ( $assetNode + ".frozen")` ) {
    	print "Error: Asset is not frozen\n";
	return 0;
    }

    // unfreeze asset
    setAttr  ( $assetNode + ".frozen" ) 0;
    // unfreeze input merge nodes
    string $inputMergeCon[] = `listConnections -type "houdiniInputMerge" $assetNode`;
    for($merge in  $inputMergeCon) {
        setAttr  ( $merge + ".frozen" ) 0;
    }
    houdiniAsset -reloadNoSync $assetNode;

    // can't restore the connections if one of the cached connection atts isn't there
    if(!`attributeExists "cachedSrc" $assetNode` || !`attributeExists "cachedDst" $assetNode`) {
        if(`attributeExists "cachedDst" $assetNode`)
	    deleteAttr ( $assetNode + ".cachedDst");
        if(`attributeExists "cachedSrc" $assetNode`)
	    deleteAttr ( $assetNode + ".cachedSrc");
        return 0;
    }

    // set the asset node to blocking - we don't want it to cook on each connectAttr
    setAttr  ( $assetNode + ".nodeState") 2;
    // disconnect output objects
       
    int $ai = 0;
    int $numCon = `getAttr -size  ($assetNode + ".cachedSrc")`;
    for($ai = 0; $ai  < $numCon; $ai++) {
	string $src = `getAttr ( $assetNode + ".cachedSrc[" + $ai +"]")`;
	string $dst = `getAttr ( $assetNode + ".cachedDst[" + $ai +"]")`;
	connectAttr $src $dst;
    }
    
    setAttr  ( $assetNode + ".nodeState") 0;

    deleteAttr ( $assetNode + ".cachedSrc");
    deleteAttr ( $assetNode + ".cachedDst");

    return 1;
}

